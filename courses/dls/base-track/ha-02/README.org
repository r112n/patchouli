#+TITLE: Домашнее задание. Numpy и линейная алгебра

* Тестовые задания
** Task 1
Почему библиотека NumPy работает с массивами быстрее, чем обычный
интерпретатор Python?

- [ ] Библиотека NumPy использует специальные ускорители, которые
  расположены на удаленных кластерах и при подключении к Интернету
  процесс автоматически ускоряется
- [x] Библиотеки, написанные на интерпретируемых языках (Python)
  работают медленнее, чем бибилиотеки, написанные на компилируемых
  (Си, Java, Фортран). NumPy написан на компилируемых языках.
- [ ] NumPy -- библиотека, использующая методы машинного обучения для
  ускорения работы. Так, она способна анализировать, что пользователь
  использует чаще и выдавать бОльшие вычислительные мощности на эти
  методы
- [ ] Библиотеки, написанные на интерпретируемых языках (Python)
  работают быстрее, чем библиотеки, написанные на компилируемых (Си,
  Java, Фортран). NumPy написан на интерпретируемом языке.

** Task 2
Пусть вам даны матрицы A и B размеров NxM и KxL.
В каком случае их можно перемножать?
(ответ может быть один, а может быть несколько)

(Примечание: квадратные матрицы -- это матрицы, у которых число строк равно числу столбцов)

- [ ] Можно перемножать только квадратные матрицы
- [ ] Только если N=L, M=K
- [ ] Перемножать можно любые матрицы. Свободные ячейки в данном
  случае дополняются нулями
- [x] Только если M=K (N и L любые натуральные числа)
- [ ] Только если N=K (M и L любые натуральные числа) 

** Task 3
Чему равно скалярное произведение векторов (1,2,3) и (-1,-5,-6,-7)?

- [ ] -29
- [x] Нельзя скалярно умножить
- [ ] (-1, -10, -18, -7)
- [ ] 0

** Task 4
Чему равно скалярное произведение векторов (10, 20, 40) и (-1, 0, 2)?

- [ ] Нельзя скалярно умножить
- [ ] 0
- [x] 70
- [ ] (-10, 0, 80)

** Task 5
Умножьте матрицы $(A \cdot B)$ вручную (матричным произведением):

$$
A = \begin{pmatrix}
5 & 1 & -2 & 0 \\
0 & 3 &  4 & 3 \\
2 & 3 &  1 & 1
\end{pmatrix}
$$

$$
B = \begin{pmatrix}
1 & -3 \\
2 & -2 \\
3 & -1 \\
0 &  0
\end{pmatrix}
$$

У получившейся матрицы посчитайте сумму элементов. Чему она равна?

- [ ] -10
- [ ] Нельзя матрично умножить
- [ ] 10
- [ ] 8
- [x] -8

** Task 6

Перемножение матриц

Напишите две функции,
каждая из которых перемножает две квадратные матрицы:
одна без использования встроенных функций numpy,
а другая --- с помощью numpy.
На вход первой задаче подаются списки размера size
по size элементов в каждом.
На вход второй задаче подаются объекты типа
np.ndarray --- квадратные матрицы одинакового размера. 

Первая функция должна возвращать список списков,
а вторая -- np.array.


#+BEGIN_SRC python :tangle "./programs/6.py"
    import numpy as np

    def no_numpy_mult(first, second):
      """
      param first: list of "size" lists, each contains "size" floats
      param second: list of "size" lists, each contains "size" floats
      """
      result = list()
      for i in range(len(first)):
          row = list()
          for j in range(len(second[0])):
              elem = 0
              for k in range(len(first[0])):
                 elem += first[i][k] * second[k][j]
              row.append(elem)
          result.append(row)

      return result

  def numpy_mult(first, second):
      """
      param first: np.array[size, size]
      param second: np.array[size, size]
      """
      result = np.matmul(first, second)
      return result
#+END_SRC

** Task 7
Вам подаются на вход два вектора a и b в трехмерном
пространстве. Реализуйте их скалярное произведение с помощью numpy и
без.

#+BEGIN_SRC python :tangle "./programs/7.py"
  import numpy as np
  def no_numpy_scalar(v1, v2):
    result = sum(list(map(lambda x,y: x*y, v1, v2)))
    return result

  def numpy_scalar(v1, v2):
    return np.dot(v1, v2)
#+END_SRC

** Task 8
Напишите функцию, которая находит сумму четных элементов на главной
диагонали квадратной матрицы (именно чётных элементов, а не элементов
на чётных позициях!). Если чётных элементов нет, то
вывести 0. Используйте библиотеку numpy.

#+BEGIN_SRC python :tangle "./programs/8.py"
  import numpy as np

  def diag_2k(a):
    diag = np.diagonal(a)
    result = diag[diag % 2 == 0].sum() 
    return result
#+END_SRC

** Task 9

На вход дан двумерный массив $X$.
Напишите функцию,
которая для каждой строчки $x = (x_1, x_2, \ldots, x_n)$
массива $X$ строит строчку $s = (s_1, s_2, \ldots, s_n)$,
где $s_k=x_1+...+x_k$​,
а затем выдаёт массив из построенных строчек.
Используйте библиотеку numpy (вам поможет функция cumsum).
Выходом функции должен быть двумерный массив той же формы,
что и $X$.

#+BEGIN_SRC python :tangle "./programs/9.py"
  import numpy as np

  def cumsum(A):
      result = np.cumsum(A, axis=1)
      return result
#+END_SRC

** Task 10
Задан двумерный массив $X$.
Для каждой строчки массива $X$ необходимо сделать следующее преобразование.

Пусть дана строчка $x$.
Необходимо построить новый массив,
где все элементы с нечетными индексами требуется заменить на число $a$
(значение по умолчанию $a = 1$).
Все элементы с четными индексами нужно возвести в куб.
Затем записать элементы в обратном порядке относительно их позиций.
В конце требуется слить массив $x$ с преобразованным $x$
и вернуть на выход функции (естественно, выход должен быть numpy-массивом).

Напишите функцию,
которая выполняет данное преобразование для каждой строчки двумерного
массива $X$.
Массив $X$ при этом должен остаться без изменений.

Используйте библиотеку numpy.

#+BEGIN_SRC python :tangle "./programs/10.py"
  import numpy as np
    
  def transform(X, a=1):
      """
      param X: np.array[batch_size, n]
      """
      new_X = np.array(X)
      new_X[:,1::2] = a
      new_X[:,::2] **= 3
      new_X = np.flip(new_X, axis=1)
      return np.concatenate((X, new_X), axis=1)
#+END_SRC

** Task 11
С помощью numpy написать функцию для кодирования массива (Run-length
encoding). Все подряд повторения элементов функция сжимает в один
элемент и считает количество повторений. Функция возвращает кортеж из
двух numpy-векторов одинаковой длины. Первый содержит элементы, а
второй — сколько раз их нужно повторить.

Пример: ~encode(np.array([1, 2, 2, 3, 3, 1, 1, 5, 5, 2, 3, 3])) =
(np.array([1, 2, 3, 1, 5, 2, 3]), np.array([1, 2, 2, 2, 2, 1, 2]))~

#+BEGIN_SRC python :tangle "./programs/11.py"
  import numpy as np
  def encode(a):
      arr, cnt = np.array([]), np.array([])

      curr_elem, curr_cnt = a[0], 1
      for i in a[1:]:
          if i == curr_elem:
              curr_cnt += 1
          else:
              cnt, arr = np.append(cnt, curr_cnt), np.append(arr,curr_elem)
              curr_elem, curr_cnt = i, 1
      return np.append(arr, curr_elem), np.append(cnt, curr_cnt)
#+END_SRC

